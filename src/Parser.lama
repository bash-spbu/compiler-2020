-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, val, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (val)
  | _    -> val
  esac
}

fun assertVoid (atr, val, loc) {
  case atr of
    Void -> val
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

local
  primary = memo $ eta syntax (
    -- (expression)
      s["("] e=exp s[")"]
      {
        fun (a) { e(a) }
      }

    -- decimal constant
    | loc=pos
      x=decimal 
      { 
        fun (a) { assertValue(a, Const(stringInt(x)), loc) } 
      }

    -- identifier
    | x=lident 
      { 
        fun (a) {
          case a of
            Ref  -> Ref (x)
          | Void -> Ignore (Var (x))
          | _    -> Var (x)
          esac
        }
      }

    -- skip
    | loc=pos
      kSkip 
      { 
        fun (a) { assertVoid(a, Skip, loc) } 
      }

    -- read(var)
    | loc=pos
      kRead s["("] x=lident s[")"] 
      { 
        fun (a) { assertVoid(a, Read(x), loc) } 
      }

    -- write(exp)
    | loc=pos
      kWrite s["("] e=exp s[")"] 
      { 
        fun (a) { assertVoid(a, Write(e(Val)), loc) } 
      }

    -- if c_0 then s_0 {elif c_i then s_i} [else s_e] fi
    | loc=pos
      kIf   cond=exp 
      kThen body=exp
      elifs=(-kElif exp -kThen exp)*
      else_=(-kElse exp)?
      kFi
      {
        fun(a) { 
          If(
            cond(Val),
            body(a),
            foldr(
              fun (acc, [cond, body]) { If(cond(Val), body(a), acc) }, 
              case else_ of 
                Some(body) -> body(a) 
              | None -> assertVoid(a, Skip, loc)
              esac,
              elifs
            )
          ) 
        }
      }

    -- while cond do body od
    | loc=pos
      kWhile cond=exp kDo body=exp kOd 
      { 
        fun (a) { assertVoid(a, While(cond(Val), body(Void)), loc) } 
      }

    -- repeat body until cond
    | loc=pos
      kRepeat body=exp kUntil cond=primary 
      { 
        fun (a) { assertVoid(a, Repeat(body(Void), cond(Val)), loc) } 
      }

    -- for init, cond; iter do body od
    | loc=pos
      kFor init=exp s[","] cond=exp s[","] iter=exp kDo body=exp kOd 
      { 
        fun (a) { 
          assertVoid(
            a, 
            Seq(init(Void), While(cond(Val), Seq(body(Void), iter(Void)))), 
            loc
          ) 
        } 
      }
    
  ),

  basic = memo $ eta (
    expr (
      { [Right, 
          singleton([ 
            s(":="),
            fun (l, loc, r) {
              fun (a) { assertValue(a, Assn(l(Ref), r(Val)), loc) }
            }
          ])
        ]
      , [Left, map (binop, singleton ("!!"))]
      , [Left, map (binop, singleton ("&&"))]
      , [Nona, map (binop, {"==", "!=", "<", ">", "<=", ">="})]
      , [Left, map (binop, {"+", "-"})]
      , [Left, map (binop, {"*", "/", "%"})]
      },
      primary
    )(id)
  ),

  exp = memo $ eta syntax (
      basic 
    | s1=basic s[";"] s2=exp { fun (a) { Seq(s1(Void), s2(a)) } }
  );

-- Public top-level parser
public parse = syntax (s=exp {s (Void)});
